# 贪心算法经典题总结（题 455, 135, 435）
## 🔍 贪心算法特征关键词


在 LeetCode 中，如果题目满足以下特征，往往适合使用贪心算法：

- **最小数量**：如“最少要做什么”
- **最大收益 / 数量**：如“最多能获得什么”
- **局部决策**可推进**全局最优**
- 有**排序 + 一次遍历 / 双向遍历**的潜力

## 🧠 定义

贪心算法是一种在每一步选择中都采取**在当前状态下最优（最有利）选择**的算法策略。

它期望通过一系列局部最优，最终得到全局最优解。

问题的整体最优解可以通过一系列**局部最优解**组合而成，**每一步只考虑当前最优选项**。

子问题之间**不互相影响**


---

## 1. 🍪 455. Assign Cookies

**题目**：[Assign Cookies](https://leetcode.com/problems/assign-cookies/)

### 🧾 题意：

- 若干个小孩，若干个饼干。
- 每个小孩有一个属性：饥饿度
- 每个饼干有一个属性：饱食度
- 每个小孩只能吃一个饼干
- 如果这个饼干的饱食度高于这个小孩的饥饿度就饱了
- 求<mark>最多</mark>喂饱多少个孩子  

#### 举例1：
题目输入：`g=[1,2,3] s=[1,1]`  
意味着有三个小孩，分别饿1，饿2，饿3  
但是只有两个饼干，分别饱1，饱1  
答案输出：1，因为只有第一个小孩吃一块饼干能吃饱，即 饥饿 = 饼干饱食度

#### 举例2：
题目输入：`g=[1,2] s=[1,2,3]`  
意味着有三个小孩，分别饿1，饿2  
但是有三块饼干，分别饱1，饱2，饱3  
答案输出：2，第一个小孩饿1，吃1；第二个小孩饿2，吃2；第三个饼干没人吃

数学表达：
- 每个孩子有一个最小饥饿度 `g[i]`
- 每块饼干有一个饱腹度 `s[j]`
- 每个孩子最多得到一块饼干，饼干满足 `s[j] >= g[i]` 时可喂饱

### 解法：贪心策略

- 排序：孩子饥饿度、饼干大小升序排序
- 用双指针遍历两个数组
- 优先给“最容易喂饱”的孩子最小的饼干  
### 代码：

```python
children.sort()
cookies.sort() #分别排序，这是贪心算法的常见操作
child_i = cookie_j = 0 #双指针
while child_i < len(children) and cookie_j < len(cookies):
    if children[child_i] <= cookies[cookie_j]: #假如当前小孩i可以用饼干j喂饱
        child_i += 1 #那么这个小孩就解决了（局部问题得到解决，贪心），下一个小孩
    cookie_j += 1 
    #无论小孩有没有饱，都看下一个：因为如果饱了，那饼干就吃了。
    #没吃饱那这个饼干也不用管了，题目不要求你关心饼干的命运
return child_i 
#返回最后一个饱的了小孩的代号；因为先前排序，所以排前面的小孩一定最容易喂饱
#并且如果小孩不吃饱，child_i是不会增长的。因此这个代号就是喂饱的小孩数。
```

### 时间复杂度：

$O(n log n + m log m)$

排序为主要成本  
排序的成本经常为 $n log n$

---
## 2. 🍬 135. Candy

**题目**：[Candy](https://leetcode.com/problems/candy/)  

### 🧾 题意：

- 每个孩子有一个评分 `ratings[i]`
- 每人至少 1 个糖果
- 如果一个孩子比旁边一个孩子的评分高，则必须比另一个孩子多一个糖果
- 求最少糖果总数  

#### 举例1：
孩子的评分  
`ratings == [2,4,3,5,7,5,6]`  
那么小孩的糖果数量应该为：  
`candies == [1,2,1,2,3,2,3]`  
答案：返回 `sum(candies) == 14`  
###  解法：两次遍历 + 局部修正

- 初始化每人 1 个糖果
- 第一次从左往右，处理“右边评分高”的情况    
- 第二次从右往左，处理“左边评分高”的情况（保留最大）

### 代码：

```python
o = [1] * len(ratings) # 初始化，每个孩子先给一个糖果
for i in range(1, len(ratings)): # 从第二个孩子开始遍历，到最后一个孩子
    if ratings[i] > ratings[i - 1]: # 从左到右：如果当前孩子比左边高分
        o[i] = o[i - 1] + 1 # 则这个孩子有前一个孩子的糖果+1的糖果
for i in range(len(ratings) - 2, -1, -1): # 从倒数第二开始遍历，一直到第一个孩子
    if ratings[i] > ratings[i + 1]: # 从右到左，如果这个孩子比右边高分
        o[i] = max(o[i], o[i + 1] + 1) # 注意
        #这里之所以是max()，是因为这是从右到左的遍历
        #有可能当前孩子已经比右边孩子的多2个及以上
        #所以不可以让这个孩子的已有的糖果被覆盖（变少）
        #这样这个孩子的糖果就会比左边的少
        #这种情况在第二次遍历的时候不能处理。
        
return sum(o)
```

---

## 3. 📆 435. Non-overlapping Intervals

**题目**：[Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)
### 题意：

- 给定一组区间 [start, end]
- 删除**最少数量**的区间，使剩下的区间**互不重叠**：例如`[1,2], [2,3]`不重叠，`[1,3], [2,4]`重叠
- 返回：最少需要去掉多少区间？

#### 举例1：
给定区间：`[1,2], [2,4], [1,3]`  
需要去掉`[1,3]`
返回 `1`

### 解法：贪心选择“结束最早”的区间

- 先按 end 升序排序
- 每次选“当前能选的、结束最早”的区间
- 如果当前区间和上一个选中的区间不重叠，就保留，否则就删除
### 代码：

```python
def eraseOverlapIntervals(intervals: List[List[int]]) -> int: 
    intervals.sort(key=lambda x: x[1]) # 按end进行排序
    removed = 0 # removed计数器初始化为0
    prev_end = intervals[0][1] # 一个指针记录第一个区间的end
    for i in range(1, len(intervals)): #从第二个开始数到最后一个
        if prev_end > intervals[i][0]: #陷阱：这里是前一个的end和本区间的start比
            removed += 1
            #如果前区间end比本区间start大，意味着有重叠
            #需要去掉本区间。然而，因为题目不要求返回区间，所以只需要计算removed
            #由于本区间被去除，所以prev_end不会被修改。例如，如果i=1比i=0大
            #那么i=2继续和i=0比
        else:
            prev_end = intervals[i][1] 
            #如果前区间end比本区间start小或者相等，意味着不重叠
            #那么不用去除本区间，而是记录下本区间的end作为prev_end
    return removed
```

## 📚 理论背景：区间调度问题的贪心最优性

本题是**经典区间调度问题**：

> 从多个区间中选择最多个互不重叠的区间
  
- 已被数学证明：**总是选择结束时间最早的区间**，能保证全局最优解
- 理由是：结束时间早，给后面留的时间多，有更多选择

这类问题具有：
- **贪心选择性质**（局部最优 = 全局最优）
- **最优子结构**（子问题最优可组成全问题最优）

---
# 边缘情况：
此类题型没有显著的边缘情况需要考虑

## 🔚 总结：贪心算法常识关键词

|**关键词**|**通常含义**|**可能适用策略**|
|---|---|---|
|“minimum”|求最小次数、代价、代入值|贪心/排序/优先队列等|
|“maximum”|求最大数目、价值、收益|贪心/动态规划|
|“non-overlapping”|区间、时间线、任务安排|区间调度贪心|
|“each must…”|每个元素有最低/必须满足的条件|初始赋值 + 局部修正策略|

