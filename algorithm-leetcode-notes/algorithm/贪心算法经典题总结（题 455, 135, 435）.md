# 贪心算法经典题总结（题 455, 135, 435）
## 🔍 贪心算法特征关键词


在 LeetCode 中，如果题目满足以下特征，往往适合使用贪心算法：

- **最小数量**：如“最少要做什么”
- **最大收益 / 数量**：如“最多能获得什么”
- **局部决策**可推进**全局最优**
- 有**排序 + 一次遍历 / 双向遍历**的潜力

---

## 1. 🍪 455. Assign Cookies

**题目**：[Assign Cookies](https://leetcode.com/problems/assign-cookies/)

### 🧾 题意：

- 每个孩子有一个最小饥饿度 `g[i]`
- 每块饼干有一个饱腹度 `s[j]`
- 每个孩子最多得到一块饼干，饼干满足 `s[j] >= g[i]` 时可喂饱
- 求最多喂饱多少个孩子  

### ✅ 解法：贪心策略

- 排序：孩子饥饿度、饼干大小升序排序
- 用双指针遍历两个数组
- 优先给“最容易喂饱”的孩子最小的饼干  

### 🧠 代码：

```
children.sort()
cookies.sort()
child_i = cookie_i = 0
while child_i < len(children) and cookie_i < len(cookies):
    if children[child_i] <= cookies[cookie_i]:
        child_i += 1
    cookie_i += 1
return child_i
```

### 📌 时间复杂度：

**O(n log n + m log m)**

### 排序为主要成本

---

## 2. 🍬 135. Candy

  

**题目**：[Candy](https://leetcode.com/problems/candy/)

  

### 🧾 题意：

- 每个孩子有一个评分 ratings[i]
- 每人至少 1 个糖果
- 如果 ratings[i] > ratings[i - 1]，i 要比左边多糖果；反之亦然
- 求最少糖果总数  

###  解法：两次遍历 + 局部修正

- 初始化每人 1 个糖果
- 第一次从左往右，处理“右边评分高”的情况    
- 第二次从右往左，处理“左边评分高”的情况（保留最大）

### 🧠 代码：

```
o = [1] * len(ratings)
for i in range(1, len(ratings)):
    if ratings[i] > ratings[i - 1]:
        o[i] = o[i - 1] + 1
for i in range(len(ratings) - 2, -1, -1):
    if ratings[i] > ratings[i + 1]:
        o[i] = max(o[i], o[i + 1] + 1)
return sum(o)
```

### 📌 关键词提示：“minimum total”、“each must get at least”、“greater rating gets more”

---

## 3. 📆 435. Non-overlapping Intervals

  

**题目**：[Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)

  

### 🧾 题意：

- 给定一组区间 [start, end]
    
- 删除最少数量的区间，使剩下的区间**互不重叠**
    

  

### ✅ 解法：贪心选择“结束最早”的区间

- 先按 end 升序排序
- 每次选“当前能选的、结束最早”的区间
- 如果当前区间和上一个选中的区间不重叠，就保留，否则就删除

### 🧠 代码：

```
intervals.sort(key=lambda x: x[1])
count = 0
prev_end = float('-inf')
for start, end in intervals:
    if start < prev_end:
        count += 1
    else:
        prev_end = end
return count
```

### 🧠 例子：

```
intervals = [[1,2],[1,3],[2,3],[3,4]]
# 排序后: [[1,2],[1,3],[2,3],[3,4]]
# 可保留: [1,2], [2,3], [3,4]
# 需删除: [1,3] → 删除数量为 1
```

---

## 📚 理论背景：区间调度问题的贪心最优性

本题是**经典区间调度问题**：

> 从多个区间中选择最多个互不重叠的区间
  
- 已被数学证明：**总是选择结束时间最早的区间**，能保证全局最优解
- 理由是：结束时间早，给后面留的时间多，有更多选择

这类问题具有：
- **贪心选择性质**（局部最优 = 全局最优）
- **最优子结构**（子问题最优可组成全问题最优）

---

# 边缘情况：
此类题型没有显著的边缘情况需要考虑

## 🔚 总结：贪心算法常识关键词

|**关键词**|**通常含义**|**可能适用策略**|
|---|---|---|
|“minimum”|求最小次数、代价、代入值|贪心/排序/优先队列等|
|“maximum”|求最大数目、价值、收益|贪心/动态规划|
|“non-overlapping”|区间、时间线、任务安排|区间调度贪心|
|“each must…”|每个元素有最低/必须满足的条件|初始赋值 + 局部修正策略|

