
# React Effect 学习笔记：同步组件与外部系统

## 1. Effect 是什么？为什么需要它？

### 1.1 Effect 的核心作用

在 React 中，**Effect** 是一种特殊的机制，它允许你的组件在 **完成渲染之后**，去执行一些与 React **外部世界** 交互的代码。

**举例说明“外部世界”：**

- **浏览器自身的功能：** 比如：
    - 控制视频播放和暂停（例如 `<video>` 标签的 `play()` 和 `pause()` 方法）。
    - 修改网页的标题。
    - 监听鼠标滚动事件、键盘输入事件。
    - 让一个输入框自动获得焦点。
- **网络：** 从服务器获取数据（发送 `fetch` 请求），或者向服务器发送数据（如分析日志）。
- **第三方库：** 比如你使用了像 jQuery 插件或者复杂的地图库，它们有自己的操作方式，Effect 就是你让 React 组件和它们“对话”的桥梁。

### 1.2 Effect 与其他代码的区别

理解 Effect，需要先明确 React 组件中的三种不同类型的代码：

- **渲染代码：**
    - **做什么：** 只负责“画画”，即根据组件的 `props` 和 `state` 来生成最终在页面上显示的内容（JSX）。
    - **特点：** 必须是“纯粹”的。这意味着它不能有任何副作用，不能改变外部世界，不能直接操作 DOM，也不能发起网络请求。就像一个计算器，输入 `2 + 2` 永远只输出 `4`，不会有其他额外的影响。
- **事件处理程序：**
    - **做什么：** 响应用户**明确的动作**，比如点击按钮、在输入框里打字。它们会“做一些事情”。
    - **特点：** 会包含“副作用”（比如更新 `state`、提交表单、页面跳转）。这些副作用是 **由用户的某个交互动作直接触发的**。
- **Effect（副作用）：**
    - **做什么：** 由 **渲染本身引起** 的副作用。它不是用户点击了某个按钮才发生，而是当组件出现在页面上、或者它的某些数据显示变化时，就应该发生。
    - **特点：** 在 React 完成渲染并更新页面上的 DOM 之后才运行。它是将 React 组件与上述提到的“外部系统”同步的最佳时机。

**简单理解：**

- **渲染：** “告诉我该画什么。”（纯计算）
- **事件：** “用户做了这个，我需要这样回应。”（响应用户行为）
- **Effect：** “我画好了，现在是时候让它和外面世界同步了。”（响应渲染结果，与外部系统交互）

## 2. 如何编写 Effect？

编写一个 Effect 通常有三个步骤：

### 2.1 步骤一：声明 Effect

1. **导入 `useEffect` Hook：**
    
    ```jsx
    import { useEffect } from 'react';
    ```
    
2. 在组件内部调用 useEffect：
    
    把你要执行的“副作用”代码放在 useEffect 接收的第一个参数（一个函数）里面。
    
    ```jsx
    function MyComponent() {
      useEffect(() => {
        // 这里的代码会在每次组件渲染完成后运行
        console.log('Effect 运行了！');
      });
      return <div>Hello, React!</div>;
    }
    ```
    
    为什么 Effect 代码不会立即运行？
    
    useEffect 会“延迟”这段代码的运行。它会等到 React 完成了所有的“画画”工作（渲染），并且页面上的 DOM 元素都更新完毕了，才会执行 Effect 里面的代码。这样你就可以在 Effect 里安全地操作 DOM 元素，因为它们已经真实地存在于页面上了。
    

### 2.2 步骤二：指定 Effect 的依赖项

默认情况下，Effect 会在 **每次渲染后** 都运行。这通常不是你想要的，因为：

- **性能问题：** 频繁地连接服务器、触发动画可能会很慢。
- **行为异常：** 比如，你可能只希望在组件第一次出现时播放动画，而不是每次组件内容更新时都播放。

为了控制 Effect 的运行频率，你需要给 `useEffect` 提供第二个参数：一个 **依赖数组**。

```jsx
useEffect(() => {
  // Effect 里的代码
}, [dep1, dep2]); // 只有当 dep1 或 dep2 的值改变时，Effect 才会重新运行
```

> [!IMPORTANT]
> 依赖数组里面是**值**，当这个值发生变化的时候，调用 Effect  
> 这个值可以是 props，或者是 state（useState)  
> 传入ref无效，不会调用 Effect

**依赖数组的作用：**

- React 会比较 `dep1` 和 `dep2`（以及数组中其他任何依赖项）在 **当前渲染** 和 **上一次渲染** 时的值。
- 只有当数组中的 **任何一个** 依赖项的值发生变化时，React 才会重新运行这个 Effect。
- 如果所有依赖项的值都和上一次一样，Effect 就会被跳过，不会重新运行。
- React 使用 [`Object.is`](https://www.google.com/search?q=%5Bhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is%5D\(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\)) 来比较依赖项的值。

**特殊情况：**

- **空数组 `[]`：**
    
    ```jsx
    useEffect(() => {
      // 这里的代码只会在组件“挂载”时（即第一次出现在页面上时）运行一次
    }, []);
    ```
    
    当你确定 Effect 只需要在组件第一次显示时执行一次（比如建立全局的聊天连接），就使用空数组。
- **不传依赖数组：**
    
    ```jsx
    useEffect(() => {
      // 这里的代码会在每次渲染后运行
    });
    ```
    
    如果你不提供第二个参数，Effect 会在组件的每一次渲染后都运行。这通常只在你确定 Effect 的行为需要与所有 `props` 或 `state` 的变化保持同步时才使用。

Linter 的帮助：

React 的 linter 工具（通常在你的代码编辑器中显示）会帮助你。如果你的 Effect 代码内部使用了某个 props 或 state，但你没有把它包含在依赖数组中，linter 会发出警告，提醒你添加。这可以帮助你避免很多常见的 bug。

### 2.5 步骤三：按需添加清理（Cleanup）函数

有些 Effect 在完成任务后，需要进行“清理”工作，以避免资源泄露或不必要的行为。

- 建立的 **连接**（如聊天服务器）需要 **断开**。
- **订阅** 的事件（如键盘输入）需要 **退订**。
- 设置的 **定时器** 需要 **清除**。
- 发出的 **数据请求** 需要 **中止** 或 **忽略结果**。

你可以在 Effect 函数中 **返回一个函数**，这个返回的函数就是清理函数：

```jsx
useEffect(() => {
  const connection = createConnection(); // 建立连接
  connection.connect();

  return () => { // 这是清理函数！
    connection.disconnect(); // 断开连接
  };
}, []);
```

**清理函数的运行时机：**

1. **Effect 重新运行之前：** 当 Effect 因为依赖项变化而需要重新运行时，React 会先调用 **上一次 Effect 返回的清理函数**。
2. **组件卸载时：** 当组件从页面上被移除（卸载）时，React 会最后一次调用 **当前正在运行的 Effect 所返回的清理函数**。

**目的：** 清理函数就像一个“善后”人员，确保 Effect 之前所做的任何“痕迹”都被清除掉，保证资源不被滥用。

## 3. 为什么在开发环境下 Effect 会运行两次？（核心理解）

这是很多 React 新手会感到困惑的地方，但理解它对于写出健壮的应用非常重要。

### 3.1 现象：日志打印两次

你可能会发现，即使你的 Effect 设置了空依赖数组 `[]`（理论上只运行一次），但在开发环境下，控制台的日志却打印了两次，例如 “✅ 连接中……” 出现了两次。

### 3.2 真正的 Bug 根源

假设你的聊天室组件没有清理函数。当用户在应用中从聊天室页面切换到其他页面（组件被卸载），再切换回聊天室页面（组件重新挂载）时，会发生什么？

- 第一次挂载：建立一个连接。
- 卸载：连接没有关闭。
- 第二次挂载：建立第二个连接。

这样，随着用户反复切换，连接会不断累积，导致应用性能下降，甚至崩溃。这种 bug 在大型应用中很难被手动测试出来。

### 3.3 React 的“严格模式”和“体检”机制

为了帮助你主动发现这类难以察觉的 bug，在 **开发环境** 中（默认开启 [严格模式](https://zh-hans.react.dev/reference/react/StrictMode) 时），React 会做一件特殊的事情：

- 它会在组件 **首次挂载后立即重新挂载一次**。这是一种模拟“卸载 -> 重新挂载”的压力测试。

**目的：** 如果你的 Effect 没有正确的清理函数，这个“运行两次”的机制就会立刻暴露问题。比如，如果你没有清理函数来断开连接，你就会看到两次“连接中”的日志，这正是 React 在提醒你：**“你的 Effect 可能存在资源未清理的问题！”**

### 3.4 正确的处理方式：拥抱它并添加清理函数

**关键点：** 你不应该去阻止 Effect 运行两次，而是应该**修复你的 Effect，让它即使运行两次也能正常工作**。

- **添加清理函数：** 如上面第三步所述，为你的 Effect 返回一个清理函数。
    
- **开发环境日志：** 有了清理函数后，开发环境下你会看到类似这样的日志：
    
    ```
    ✅ 连接中……
    ❌ 连接断开。
    ✅ 连接中……
    ```
    
    这正是 React 想要看到的结果！它验证了你的 Effect 能够正确地“清理”自己，在模拟卸载后能恢复到一个干净的状态并再次建立连接。
    
- **生产环境行为：** 在生产环境中，React 不会执行这个“体检”行为，所以你的 Effect 仍然只会运行一次，不会有额外的连接和断开。
    

### 3.5 误区：不要使用 `ref` 来防止 Effect 运行两次

有些新手可能会尝试用 `useRef` 来“记住”是否已经运行过 Effect，从而阻止它运行第二次。

```jsx
// 🚩 错误做法：掩盖问题，没有解决 bug
const hasConnectedRef = useRef(false);
useEffect(() => {
  if (!hasConnectedRef.current) {
    // 建立连接
    hasConnectedRef.current = true;
  }
}, []);
```

**为什么这是错误的？**

这种做法只是 **表面上** 让你在开发环境下只看到一次日志，但它 **没有真正修复** 你的组件在实际卸载时没有清理资源的 bug。当用户真的切换页面导致组件卸载又挂载时，第一次的连接仍然没有关闭，问题依然存在。

**记住：** “运行两次”是 React 给你的一面镜子，它在告诉你代码中可能存在的隐患。不要试图“打破”这面镜子，而应该利用它来让你的代码更健壮。

## 4. 常见 Effect 模式与清理函数

以下是一些常见 Effect 使用场景及其清理函数的处理方式：

- **管理非 React 小部件：**
    - **无需清理：** 如果多次调用同一方法没有副作用（例如 `map.setZoomLevel()`），通常不需要清理。
    - **需要清理：** 如果调用会产生资源或异常（例如 `dialog.showModal()`），则需要清理（`dialog.close()`）。
- **订阅事件：**
    - **清理：** 必须在 Effect 返回的函数中 **取消订阅** 事件（例如 `window.removeEventListener()`）。
- **触发动画：**
    - **清理：** 将动画重置到其 **初始状态**，确保动画不会残留。
- **获取数据：**
    - **清理：** 无法“撤销”已发出的网络请求，但可以设置一个 **标志位**（`let ignore = false;`）并在清理函数中将其设为 `true`。这样，当请求结果返回时，可以检查 `ignore` 标志，如果为 `true` 则 **忽略其结果**，避免过时的请求更新 `state`。
    - **推荐：** 考虑使用像 [React Query](https://tanstack.com/query/latest) 或 [useSWR](https://www.google.com/search?q=https://swst.vercel.app/) 这样的数据获取库，它们能更好地处理缓存、去重和竞态条件。
- **发送分析报告：**
    - **清理：** 通常 **不需要**。在开发环境下，分析报告通常不会真的发送到服务器，所以多次调用无害。在生产环境下只运行一次。

## 5. 不适用于 Effect 的场景（重要误区）

有些逻辑 **绝对不应该** 放在 Effect 中：

- **初始化应用（只运行一次的全局逻辑）：**
    - 如果某些代码只需要在应用启动时（例如检查用户认证、从本地存储加载数据）运行一次，并且与组件的渲染无关，请将它们放在组件的 **外部**，确保只在浏览器加载页面时执行一次。
- **执行用户明确的交互行为：**
    - 例如，“购买商品”的请求 **不应该** 放在 Effect 中。因为购买行为是由用户点击按钮等 **特定交互** 引起的，而不是由组件的渲染引起的。如果放在 Effect 里，用户切换页面再回来，可能就会触发第二次购买，造成严重问题。
    - **正确做法：** 将这类操作放在 **事件处理程序** 中（例如按钮的 `onClick` 函数）。

**总结：** 如果一个操作是因为用户“做了什么”而发生，它就是事件；如果一个操作是因为“组件显示在屏幕上”或“组件的数据发生变化”而发生，并且需要与外部系统同步，那它才是 Effect。

## 6. 每一轮渲染都有其自己的 Effect

- **Effect 会“捕获”它对应渲染时的 `props` 和 `state` 值。** 即使这些值在之后改变，Effect 内部的代码也总是使用它被创建时的那些值。这与 JavaScript 中的 [闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures) 概念紧密相关。
- 这意味着每个渲染的 Effect 都是 **相互独立** 的。
